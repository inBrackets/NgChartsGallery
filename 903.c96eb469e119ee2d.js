"use strict";(self.webpackChunkNgChartsGallery=self.webpackChunkNgChartsGallery||[]).push([[903],{903:(I,D,x)=>{x.r(D),x.d(D,{default:()=>R});var N,V=x(444),h=(x(678),{n:n=>{var i=n&&n.__esModule?()=>n.default:()=>n;return h.d(i,{a:i}),i},d:(n,i)=>{for(var l in i)h.o(i,l)&&!h.o(n,l)&&Object.defineProperty(n,l,{enumerable:!0,get:i[l]})},o:(n,i)=>Object.prototype.hasOwnProperty.call(n,i)}),O=h.n(V.default);h.d({},{});let U_getArrayExtremes=function(n,i,l){return n.reduce((f,p)=>[Math.min(f[0],p[i]),Math.max(f[1],p[l])],[Number.MAX_VALUE,-Number.MAX_VALUE])};var G=h.n(V.default.SeriesRegistry);let{sma:{prototype:c}}=G().seriesTypes,{defined:j,error:T,merge:_}=O();!function(n){let i=["bottomLine"],l=["top","bottom"],f=["top"];function p(e){return"plot"+e.charAt(0).toUpperCase()+e.slice(1)}function y(e,t){let a=[];return(e.pointArrayMap||[]).forEach(r=>{r!==t&&a.push(p(r))}),a}function A(){let M,e=this,a=e.linesApiNames,r=e.areaLinesNames,o=e.points,u=e.options,P=e.graph,S={options:{gapSize:u.gapSize}},g=[],L=y(e,e.pointValKey),v=o.length;if(L.forEach((s,m)=>{for(g[m]=[];v--;)M=o[v],g[m].push({x:M.x,plotX:M.plotX,plotY:M[s],isNull:!j(M[s])});v=o.length}),e.userOptions.fillColor&&r.length){let s=g[L.indexOf(p(r[0]))],m=1===r.length?o:g[L.indexOf(p(r[1]))],z=e.color;e.points=m,e.nextPoints=s,e.color=e.userOptions.fillColor,e.options=_(o,S),e.graph=e.area,e.fillGraph=!0,c.drawGraph.call(e),e.area=e.graph,delete e.nextPoints,delete e.fillGraph,e.color=z}a.forEach((s,m)=>{g[m]?(e.points=g[m],u[s]?e.options=_(u[s].styles,S):T('Error: "There is no '+s+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),e.graph=e["graph"+s],c.drawGraph.call(e),e["graph"+s]=e.graph):T('Error: "'+s+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),e.points=o,e.options=u,e.graph=P,c.drawGraph.call(e)}function b(e){let t,a=[],r=[];if(e=e||this.points,this.fillGraph&&this.nextPoints){if((t=c.getGraphPath.call(this,this.nextPoints))&&t.length){t[0][0]="L",a=c.getGraphPath.call(this,e),r=t.slice(0,a.length);for(let o=r.length-1;o>=0;o--)a.push(r[o])}}else a=c.getGraphPath.apply(this,arguments);return a}function C(e){let t=[];return(this.pointArrayMap||[]).forEach(a=>{t.push(e[a])}),t}function d(){let a,e=this.pointArrayMap,t=[];t=y(this),c.translate.apply(this,arguments),this.points.forEach(r=>{e.forEach((o,u)=>{a=r[o],this.dataModify&&(a=this.dataModify.modifyValue(a)),null!==a&&(r[t[u]]=this.yAxis.toPixels(a,!0))})})}n.compose=function(e){let t=e.prototype;return t.linesApiNames=t.linesApiNames||i.slice(),t.pointArrayMap=t.pointArrayMap||l.slice(),t.pointValKey=t.pointValKey||"top",t.areaLinesNames=t.areaLinesNames||f.slice(),t.drawGraph=A,t.getGraphPath=b,t.toYData=C,t.translate=d,e}}(N||(N={}));let X=N,{sma:K}=G().seriesTypes,{merge:k,extend:B}=O();class E extends K{getValues(i,l){let f,p,y,A,b,C,d,e=l.period,t=i.xData,a=i.yData,r=a?a.length:0,o=[],u=[],P=[];if(!(r<e)){for(d=e;d<=r;d++)A=t[d-1],b=a.slice(d-e,d),f=((p=(C=U_getArrayExtremes(b,2,1))[1])+(y=C[0]))/2,o.push([A,p,f,y]),u.push(A),P.push([p,f,y]);return{values:o,xData:u,yData:P}}}}E.defaultOptions=k(K.defaultOptions,{params:{index:void 0,period:20},lineWidth:1,topLine:{styles:{lineColor:"#00e272",lineWidth:1}},bottomLine:{styles:{lineColor:"#feb56a",lineWidth:1}},dataGrouping:{approximation:"averages"}}),B(E.prototype,{areaLinesNames:["top","bottom"],nameBase:"Price Channel",nameComponents:["period"],linesApiNames:["topLine","bottomLine"],pointArrayMap:["top","middle","bottom"],pointValKey:"middle"}),X.compose(E),G().registerSeriesType("pc",E);let R=O()}}]);