"use strict";(self.webpackChunkNgChartsGallery=self.webpackChunkNgChartsGallery||[]).push([[495],{495:(I,P,m)=>{m.r(P),m.d(P,{default:()=>T});var f=m(444),r=(m(678),{n:l=>{var s=l&&l.__esModule?()=>l.default:()=>l;return r.d(s,{a:s}),s},d:(l,s)=>{for(var o in s)r.o(s,o)&&!r.o(l,o)&&Object.defineProperty(l,o,{enumerable:!0,get:s[o]})},o:(l,s)=>Object.prototype.hasOwnProperty.call(l,s)}),g=r.n(f.default);r.d({},{});var p=r.n(f.default.SeriesRegistry);let{noop:L}=g(),{sma:x}=p().seriesTypes,{extend:A,correctFloat:z,defined:h,merge:D}=g();class C extends x{init(){p().seriesTypes.sma.prototype.init.apply(this,arguments);let s=this.color;this.options&&(h(this.colorIndex)&&(this.options.signalLine&&this.options.signalLine.styles&&!this.options.signalLine.styles.lineColor&&(this.options.colorIndex=this.colorIndex+1,this.getCyclic("color",void 0,this.chart.options.colors),this.options.signalLine.styles.lineColor=this.color),this.options.macdLine&&this.options.macdLine.styles&&!this.options.macdLine.styles.lineColor&&(this.options.colorIndex=this.colorIndex+1,this.getCyclic("color",void 0,this.chart.options.colors),this.options.macdLine.styles.lineColor=this.color)),this.macdZones={zones:this.options.macdLine.zones,startIndex:0},this.signalZones={zones:this.macdZones.zones.concat(this.options.signalLine.zones),startIndex:this.macdZones.zones.length}),this.color=s}toYData(s){return[s.y,s.signal,s.MACD]}translate(){let s=this,o=["plotSignal","plotMACD"];g().seriesTypes.column.prototype.translate.apply(s),s.points.forEach(function(n){[n.signal,n.MACD].forEach(function(t,c){null!==t&&(n[o[c]]=s.yAxis.toPixels(t,!0))})})}destroy(){this.graph=null,this.graphmacd=this.graphmacd&&this.graphmacd.destroy(),this.graphsignal=this.graphsignal&&this.graphsignal.destroy(),p().seriesTypes.sma.prototype.destroy.apply(this,arguments)}drawGraph(){let i,s=this,o=s.points,n=s.options,t=s.zones,c={options:{gapSize:n.gapSize}},a=[[],[]],d=o.length;for(;d--;)h((i=o[d]).plotMACD)&&a[0].push({plotX:i.plotX,plotY:i.plotMACD,isNull:!h(i.plotMACD)}),h(i.plotSignal)&&a[1].push({plotX:i.plotX,plotY:i.plotSignal,isNull:!h(i.plotMACD)});["macd","signal"].forEach((e,y)=>{s.points=a[y],s.options=D(n[`${e}Line`]?.styles||{},c),s.graph=s[`graph${e}`],s.zones=(s[`${e}Zones`].zones||[]).slice(s[`${e}Zones`].startIndex||0),p().seriesTypes.sma.prototype.drawGraph.call(s),s[`graph${e}`]=s.graph}),s.points=o,s.options=n,s.zones=t}applyZones(){let s=this.zones;this.zones=this.signalZones.zones,p().seriesTypes.sma.prototype.applyZones.call(this),this.graphmacd&&this.options.macdLine.zones.length&&this.graphmacd.hide(),this.zones=s}getValues(s,o){let i,d,e,n=o.longPeriod-o.shortPeriod,t=[],c=[],a=[],y=0,u=[];if(!(s.xData.length<o.longPeriod+o.signalPeriod)){for(e=0,i=p().seriesTypes.ema.prototype.getValues(s,{period:o.shortPeriod,index:o.index}),d=p().seriesTypes.ema.prototype.getValues(s,{period:o.longPeriod,index:o.index}),i=i.values,d=d.values;e<=i.length;e++)h(d[e])&&h(d[e][1])&&h(i[e+n])&&h(i[e+n][0])&&t.push([i[e+n][0],0,null,i[e+n][1]-d[e][1]]);for(e=0;e<t.length;e++)c.push(t[e][0]),a.push([0,null,t[e][3]]);for(e=0,u=(u=p().seriesTypes.ema.prototype.getValues({xData:c,yData:a},{period:o.signalPeriod,index:2})).values;e<t.length;e++)t[e][0]>=u[0][0]&&(t[e][2]=u[y][1],a[e]=[0,u[y][1],t[e][3]],null===t[e][3]?(t[e][1]=0,a[e][0]=0):(t[e][1]=z(t[e][3]-u[y][1]),a[e][0]=z(t[e][3]-u[y][1])),y++);return{values:t,xData:c,yData:a}}}}C.defaultOptions=D(x.defaultOptions,{params:{shortPeriod:12,longPeriod:26,signalPeriod:9,period:26},signalLine:{zones:[],styles:{lineWidth:1,lineColor:void 0}},macdLine:{zones:[],styles:{lineWidth:1,lineColor:void 0}},threshold:0,groupPadding:.1,pointPadding:.1,crisp:!1,states:{hover:{halo:{size:0}}},tooltip:{pointFormat:'<span style="color:{point.color}">\u25cf</span> <b> {series.name}</b><br/>Value: {point.MACD}<br/>Signal: {point.signal}<br/>Histogram: {point.y}<br/>'},dataGrouping:{approximation:"averages"},minPointLength:0}),A(C.prototype,{nameComponents:["longPeriod","shortPeriod","signalPeriod"],pointArrayMap:["y","signal","MACD"],parallelArrays:["x","y","signal","MACD"],pointValKey:"y",markerAttribs:L,getColumnMetrics:g().seriesTypes.column.prototype.getColumnMetrics,crispCol:g().seriesTypes.column.prototype.crispCol,drawPoints:g().seriesTypes.column.prototype.drawPoints}),p().registerSeriesType("macd",C);let T=g()}}]);