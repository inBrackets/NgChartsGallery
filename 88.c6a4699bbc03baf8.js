"use strict";(self.webpackChunkNgChartsGallery=self.webpackChunkNgChartsGallery||[]).push([[88],{88:(st,S,T)=>{T.r(S),T.d(S,{default:()=>at});var G,V=T(444),x=(T(678),{n:u=>{var i=u&&u.__esModule?()=>u.default:()=>u;return x.d(i,{a:i}),i},d:(u,i)=>{for(var n in i)x.o(i,n)&&!x.o(u,n)&&Object.defineProperty(u,n,{enumerable:!0,get:i[n]})},o:(u,i)=>Object.prototype.hasOwnProperty.call(u,i)}),A=x.n(V.default),I=x.n(V.default.Chart),k=x.n(V.default.SeriesRegistry);let{line:U}=k().seriesTypes,{addEvent:b,fireEvent:X,error:F,extend:H,isArray:w,merge:J,pick:Q}=A(),L=(u,i)=>{let n=[],e=u.pointArrayMap,p=i&&u.dataTable.modified||u.dataTable;if(!e)return u.getColumn("y",i);let r=e.map(h=>u.getColumn(h,i));for(let h=0;h<p.rowCount;h++){let d=e.map((f,c)=>r[c]?.[h]||0);n.push(d)}return n};class N extends U{destroy(){this.dataEventsToUnbind.forEach(function(i){i()}),super.destroy.apply(this,arguments)}getName(){let i=[],n=this.name;return n||((this.nameComponents||[]).forEach(function(e,p){i.push(this.options.params[e]+Q(this.nameSuffixes[p],""))},this),n=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?" ("+i.join(", ")+")":"")),n}getValues(i,n){let t,l,e=n.period,p=i.xData||[],r=i.yData,h=r.length,d=[],f=[],c=[],s=-1,a=0,o=0;if(!(p.length<e)){for(w(r[0])&&(s=n.index?n.index:0);a<e-1;)o+=s<0?r[a]:r[a][s],a++;for(t=a;t<h;t++)o+=s<0?r[t]:r[t][s],l=[p[t],o/e],d.push(l),f.push(l[0]),c.push(l[1]),o-=s<0?r[t-a]:r[t-a][s];return{values:d,xData:f,yData:c}}}init(i,n){let e=this;super.init.call(e,i,n);let p=b(I(),"afterLinkSeries",function({isUpdating:r}){if(r)return;let h=!!e.dataEventsToUnbind.length;if(!e.linkedParent)return F("Series "+e.options.linkedTo+" not found! Check `linkedTo`.",!1,i);if(!h&&(e.dataEventsToUnbind.push(b(e.linkedParent,"updatedData",function(){e.recalculateValues()})),e.calculateOn.xAxis&&e.dataEventsToUnbind.push(b(e.linkedParent.xAxis,e.calculateOn.xAxis,function(){e.recalculateValues()}))),"init"===e.calculateOn.chart)e.closestPointRange||e.recalculateValues();else if(!h){let d=b(e.chart,e.calculateOn.chart,function(){e.recalculateValues(),d()})}},{order:0});e.dataEventsToUnbind=[],e.eventsToUnbind.push(p)}recalculateValues(){let h,d,f,c,i=[],n=this.dataTable,e=this.points||[],p=this.dataTable.rowCount,r=!0,t=this.linkedParent.yData,s=this.linkedParent.processedYData;this.linkedParent.xData=this.linkedParent.getColumn("x"),this.linkedParent.yData=L(this.linkedParent),this.linkedParent.processedYData=L(this.linkedParent,!0);let a=this.linkedParent.options&&this.linkedParent.dataTable.rowCount&&this.getValues(this.linkedParent,this.options.params)||{values:[],xData:[],yData:[]};delete this.linkedParent.xData,this.linkedParent.yData=t,this.linkedParent.processedYData=s;let l=this.pointArrayMap||["y"],o={};if(a.yData.forEach(m=>{l.forEach((D,P)=>{let y=o[D]||[];y.push(w(m)?m[P]:m),o[D]||(o[D]=y)})}),p&&!this.hasGroupedData&&this.visible&&this.points)if(this.cropped){this.xAxis&&(f=this.xAxis.min,c=this.xAxis.max);let m=this.cropData(n,f,c),D=["x",...this.pointArrayMap||["y"]];for(let y=0;y<(m.modified?.rowCount||0);y++){let E=D.map(M=>this.getColumn(M)[y]||0);i.push(E)}let P=this.getColumn("x");h=a.xData.indexOf(P[0]),d=a.xData.indexOf(P[P.length-1]),-1===h&&d===a.xData.length-2&&i[0][0]===e[0].x&&i.shift(),this.updateData(i)}else(this.updateAllPoints||a.xData.length!==p-1&&a.xData.length!==p+1)&&(r=!1,this.updateData(a.values));r&&(n.setColumns({...o,x:a.xData}),this.options.data=a.values),this.calculateOn.xAxis&&this.getColumn("x",!0).length&&(this.isDirty=!0,this.redraw()),this.isDirtyData=!!this.linkedSeries.length,X(this,"updatedData")}processData(){let i=this.options.compareToMain,n=this.linkedParent;super.processData.apply(this,arguments),this.dataModify&&n&&n.dataModify&&n.dataModify.compareValue&&i&&(this.dataModify.compareValue=n.dataModify.compareValue)}}N.defaultOptions=J(U.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:!1,params:{index:3,period:14}}),H(N.prototype,{calculateOn:{chart:"init"},hasDerivedData:!0,nameComponents:["period"],nameSuffixes:[],useCommonDataGrouping:!0}),k().registerSeriesType("sma",N);let{sma:j}=k().seriesTypes,{correctFloat:Z,isArray:$,merge:q}=A();class K extends j{accumulatePeriodPoints(i,n,e){let p=0,r=0;for(;r<i;)p+=n<0?e[r]:e[r][n],r++;return p}calculateEma(i,n,e,p,r,h,d){return[i[e-1],void 0===r?d:Z((h<0?n[e-1]:n[e-1][h])*p+r*(1-p))]}getValues(i,n){let s,a,l,e=n.period,p=i.xData,r=i.yData,h=r?r.length:0,d=2/(e+1),f=[],c=[],t=[],o=-1,D=0;if(!(h<e)){for($(r[0])&&(o=n.index?n.index:0),D=this.accumulatePeriodPoints(e,o,r)/e,l=e;l<h+1;l++)a=this.calculateEma(p,r,l,d,s,o,D),f.push(a),c.push(a[0]),t.push(a[1]),s=a[1];return{values:f,xData:c,yData:t}}}}K.defaultOptions=q(j.defaultOptions,{params:{index:3,period:9}}),k().registerSeriesType("ema",K);let{sma:{prototype:C}}=k().seriesTypes,{defined:tt,error:Y,merge:_}=A();!function(u){let i=["bottomLine"],n=["top","bottom"],e=["top"];function p(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function r(t,s){let a=[];return(t.pointArrayMap||[]).forEach(l=>{l!==s&&a.push(p(l))}),a}function h(){let O,t=this,a=t.linesApiNames,l=t.areaLinesNames,o=t.points,m=t.options,D=t.graph,P={options:{gapSize:m.gapSize}},y=[],E=r(t,t.pointValKey),M=o.length;if(E.forEach((g,v)=>{for(y[v]=[];M--;)O=o[M],y[v].push({x:O.x,plotX:O.plotX,plotY:O[g],isNull:!tt(O[g])});M=o.length}),t.userOptions.fillColor&&l.length){let g=y[E.indexOf(p(l[0]))],v=1===l.length?o:y[E.indexOf(p(l[1]))],it=t.color;t.points=v,t.nextPoints=g,t.color=t.userOptions.fillColor,t.options=_(o,P),t.graph=t.area,t.fillGraph=!0,C.drawGraph.call(t),t.area=t.graph,delete t.nextPoints,delete t.fillGraph,t.color=it}a.forEach((g,v)=>{y[v]?(t.points=y[v],m[g]?t.options=_(m[g].styles,P):Y('Error: "There is no '+g+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),t.graph=t["graph"+g],C.drawGraph.call(t),t["graph"+g]=t.graph):Y('Error: "'+g+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),t.points=o,t.options=m,t.graph=D,C.drawGraph.call(t)}function d(t){let s,a=[],l=[];if(t=t||this.points,this.fillGraph&&this.nextPoints){if((s=C.getGraphPath.call(this,this.nextPoints))&&s.length){s[0][0]="L",a=C.getGraphPath.call(this,t),l=s.slice(0,a.length);for(let o=l.length-1;o>=0;o--)a.push(l[o])}}else a=C.getGraphPath.apply(this,arguments);return a}function f(t){let s=[];return(this.pointArrayMap||[]).forEach(a=>{s.push(t[a])}),s}function c(){let a,t=this.pointArrayMap,s=[];s=r(this),C.translate.apply(this,arguments),this.points.forEach(l=>{t.forEach((o,m)=>{a=l[o],this.dataModify&&(a=this.dataModify.modifyValue(a)),null!==a&&(l[s[m]]=this.yAxis.toPixels(a,!0))})})}u.compose=function(t){let s=t.prototype;return s.linesApiNames=s.linesApiNames||i.slice(),s.pointArrayMap=s.pointArrayMap||n.slice(),s.pointValKey=s.pointValKey||"top",s.areaLinesNames=s.areaLinesNames||e.slice(),s.drawGraph=h,s.getGraphPath=d,s.toYData=f,s.translate=c,t}}(G||(G={}));let et=G;x.d({},{});let R=A();R.MultipleLinesComposition=R.MultipleLinesComposition||et;let at=A()}}]);