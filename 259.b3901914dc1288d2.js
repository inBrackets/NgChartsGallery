"use strict";(self.webpackChunkNgChartsGallery=self.webpackChunkNgChartsGallery||[]).push([[259],{259:(Y,V,v)=>{v.r(V),v.d(V,{default:()=>z});var P,K=v(444),u=(v(678),{n:o=>{var r=o&&o.__esModule?()=>o.default:()=>o;return u.d(r,{a:r}),r},d:(o,r)=>{for(var n in r)u.o(r,n)&&!u.o(o,n)&&Object.defineProperty(o,n,{enumerable:!0,get:r[n]})},o:(o,r)=>Object.prototype.hasOwnProperty.call(o,r)}),G=u.n(K.default);u.d({},{});let j_getArrayExtremes=function(o,r,n){return o.reduce((d,l)=>[Math.min(d[0],l[r]),Math.max(d[1],l[n])],[Number.MAX_VALUE,-Number.MAX_VALUE])};var b=u.n(K.default.SeriesRegistry);let{sma:{prototype:g}}=b().seriesTypes,{defined:X,error:S,merge:T}=G();!function(o){let r=["bottomLine"],n=["top","bottom"],d=["top"];function l(e){return"plot"+e.charAt(0).toUpperCase()+e.slice(1)}function N(e,t){let a=[];return(e.pointArrayMap||[]).forEach(s=>{s!==t&&a.push(l(s))}),a}function y(){let E,e=this,a=e.linesApiNames,s=e.areaLinesNames,i=e.points,c=e.options,p=e.graph,x={options:{gapSize:c.gapSize}},m=[],f=N(e,e.pointValKey),L=i.length;if(f.forEach((h,A)=>{for(m[A]=[];L--;)E=i[L],m[A].push({x:E.x,plotX:E.plotX,plotY:E[h],isNull:!X(E[h])});L=i.length}),e.userOptions.fillColor&&s.length){let h=m[f.indexOf(l(s[0]))],A=1===s.length?i:m[f.indexOf(l(s[1]))],I=e.color;e.points=A,e.nextPoints=h,e.color=e.userOptions.fillColor,e.options=T(i,x),e.graph=e.area,e.fillGraph=!0,g.drawGraph.call(e),e.area=e.graph,delete e.nextPoints,delete e.fillGraph,e.color=I}a.forEach((h,A)=>{m[A]?(e.points=m[A],c[h]?e.options=T(c[h].styles,x):S('Error: "There is no '+h+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),e.graph=e["graph"+h],g.drawGraph.call(e),e["graph"+h]=e.graph):S('Error: "'+h+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),e.points=i,e.options=c,e.graph=p,g.drawGraph.call(e)}function D(e){let t,a=[],s=[];if(e=e||this.points,this.fillGraph&&this.nextPoints){if((t=g.getGraphPath.call(this,this.nextPoints))&&t.length){t[0][0]="L",a=g.getGraphPath.call(this,e),s=t.slice(0,a.length);for(let i=s.length-1;i>=0;i--)a.push(s[i])}}else a=g.getGraphPath.apply(this,arguments);return a}function O(e){let t=[];return(this.pointArrayMap||[]).forEach(a=>{t.push(e[a])}),t}function M(){let a,e=this.pointArrayMap,t=[];t=N(this),g.translate.apply(this,arguments),this.points.forEach(s=>{e.forEach((i,c)=>{a=s[i],this.dataModify&&(a=this.dataModify.modifyValue(a)),null!==a&&(s[t[c]]=this.yAxis.toPixels(a,!0))})})}o.compose=function(e){let t=e.prototype;return t.linesApiNames=t.linesApiNames||r.slice(),t.pointArrayMap=t.pointArrayMap||n.slice(),t.pointValKey=t.pointValKey||"top",t.areaLinesNames=t.areaLinesNames||d.slice(),t.drawGraph=y,t.getGraphPath=D,t.toYData=O,t.translate=M,e}}(P||(P={}));let B=P,{sma:_}=b().seriesTypes,{extend:R,isArray:W,merge:w}=G();class C extends _{init(){super.init.apply(this,arguments),this.options=w({smoothedLine:{styles:{lineColor:this.color}}},this.options)}getValues(r,n){let t,a,s,c,p,d=n.periods[0],l=n.periods[1],N=r.xData,y=r.yData,D=y?y.length:0,O=[],M=[],e=[],i=null;if(D<d||!W(y[0])||4!==y[0].length)return;let x=!0,m=0;for(p=d-1;p<D;p++){if(t=y.slice(p-d+1,p+1),a=(c=j_getArrayExtremes(t,2,1))[0],isNaN(s=(y[p][3]-a)/(c[1]-a)*100)&&x){m++;continue}x&&!isNaN(s)&&(x=!1);let f=M.push(N[p]);isNaN(s)?e.push([e[f-2]&&"number"==typeof e[f-2][0]?e[f-2][0]:null,null]):e.push([s,null]),p>=m+(d-1)+(l-1)&&(i=super.getValues({xData:M.slice(-l),yData:e.slice(-l)},{period:l}).yData[0]),O.push([N[p],s,i]),e[f-1][1]=i}return{values:O,xData:M,yData:e}}}C.defaultOptions=w(_.defaultOptions,{params:{index:void 0,period:void 0,periods:[14,3]},marker:{enabled:!1},tooltip:{pointFormat:'<span style="color:{point.color}">\u25cf</span><b> {series.name}</b><br/>%K: {point.y}<br/>%D: {point.smoothed}<br/>'},smoothedLine:{styles:{lineWidth:1,lineColor:void 0}},dataGrouping:{approximation:"averages"}}),R(C.prototype,{areaLinesNames:[],nameComponents:["periods"],nameBase:"Stochastic",pointArrayMap:["y","smoothed"],parallelArrays:["x","y","smoothed"],pointValKey:"y",linesApiNames:["smoothedLine"]}),B.compose(C),b().registerSeriesType("stochastic",C);let z=G()}}]);